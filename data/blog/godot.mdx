---
title: Godot
date: '2021-05-14'
tags: ['godot', 'tutorial', 'videogames']
---

![Godot Logo](/static/images/godot/GodotLogo.png)

The [Godot](https://godotengine.org/download/windows) engine is a free, open source, videogame engine with many [assets](https://godotengine.org/asset-library/asset). To know more you can visit their [blog](https://godotengine.org/news), or use one of their [community channels](https://godotengine.org/community). To actually learn Godot you can use their [docs](https://docs.godotengine.org/en/stable/).

- 3D engine with MSAA, BSDF, scattering, anisotropy etc.
- 2D engine with title maps, grid shape, layers, lights etc.
- Official languages GDScript, C#, C++, VisualScript
- Export to iOS, Android, Windows, maxOS, Linux, UWP, BSD, Haiku.
- Files with Git, Subversion, Mercurial, PlasticSCM, Perforce.
- Plugins for Python and Nim compatibility.
- Blender models exported with Collada

## Starting Godot

When you open Godot you encounter the **Project Administrator**, use it to edit, play, search, create, import, rename or delete your projects. 

![Godot First Open](/static/images/godot/project_manager_first_open.png)

The templates section has online starters.  

![Godot Templates](/static/images/godot/editor_ui_intro_project_manager_03.png)

Every project needs a unique name, folder and selected backend (GLES2 or GLES3).

![Godot Project Manager](/static/images/godot/editor_ui_intro_project_manager_04.png)

To import a project use the search option and open the folder that contains a `project.godot` file.

![Godot Project Import](/static/images/godot/editor_ui_intro_project_manager_05.png)

When you open a project you encounter the **Project editor** that is divided in:

![Godot Editor Overview](/static/images/godot/editor_ui_intro_editor_interface_overview.png)

- Main Menus: Scene, Project, Debug, Editor, Help.
- Workspaces: 2D, 3D, Script, Assets.
- Playtest: Play project, pause, stop, play scene, play custom.
- Toolbar: Reacts to the selected workspace.
- Viewport: How the game currently looks.
- Bottom Panel: Output, Debugger, Animation, Audio.
- Docks:
	* Scene: Shows every node of the current scene.
	* Import: Properties when importing an asset to the selected node.
	* FileSystem: Organize files and assets of the project.
	* Inspector: Classes, Sections and Properties of the selected node.
	* Node: Implementation, functions and signals of the selected node.

With the **Scene Menu** you create, open, save, reload and close scenes (with `tscn` extension). With the **Project Menu** you can modify the settings, select a version control or export the project. With the **Editor Menu** you can manage export templates, and control multiple aspects of the editor itself across projects.

***

## Scenes and Nodes

A **Node** is the basic unit of Godot, every node has universal attributes:

1. A unique name.
2. Can have editable properties.
3. Can receive a callback each frame.
4. Can be extended with functions.
5. Can be the child of other node.

A **Scene** is the hierarchical organization of nodes to create a tree of nodes:

1. A scene has a root node.
2. Is is independent of other scenes with a unique file.
3. Can be instanced or used inside another scene as a node.

In the project settings `Aplication-Run-MainScene` we can select the MainScene. When we run a Godot project what we are actually doing is instancing the root node of the MainScene.

![Godot Main Scene](/static/images/godot/main_scene.png)

### Instancing example

In [this example](https://docs.godotengine.org/en/stable/_downloads/0f77439a03c9c1eb57dab630d028b82d/instancing.zip) we have a Main scene and a Ball scene. Ball is composed of a `RigidBody2D` *ball* node, while Main is composed of multiple `StaticBody2D` *obstacle* nodes. We can add Ball to Main like every other node using the link button.

![Godot Link Button](/static/images/godot/instancing_linkbutton.png)
![Godot Multiball](/static/images/godot/instancing_multiball.png.png)

If we modify Ball every instance of Ball inside Main will be updated with the new information, if we want to change a particular instance we indicate it with the **Make Unique** option, then a gray icon indicates that *this* parameter is different from the original Ball scene.

![Godot Return Button](/static/images/godot/instancing_property.png)

This design system of nodes and scenes focuses on the visual elements of the screen. It is therefore recommended to create a basic diagram of every visual element that will be expected and how they will relate to each other.

![Node Relationships](/static/images/godot/NodeRelations.jpg)

The lowest elements of the diagram are the ones expected to be described using nodes, meaning that most scenes will be composed of other scenes.

![Scene Relationships](/static/images/godot/SceneRelations.png)

***

## My First Script

The official scripting language is GDScript (loosely based on Python), let's start by creating a button that when pressed displays *Hello World!*. We will add three nodes to the MainScene:

1. Panel: Rectangular opaque background used to contain other Control nodes. It inherits from `Control < CanvasItem < Node < Object`.
	1. Button: Default button, its methods like `_pressed()` come from `BaseButton`. It inherits from `BaseButton < Control < CanvasItem < Node < Object`.
	2. Label: Rectangular plain text box. We will change its `text` property. It inherits from `Control < CanvasItem < Node < Object`.

![Script Added](/static/images/godot/script_added.png)

With all three nodes created we can add a script to the Panel node. All nodes than inherit from `Node` trigger a `_ready()` callback when they finish loading into the scene tree. Note that `_ready()` is not the node constructor but `_init()` instead, also note that the new script inherits everything from its parent node.

![Script Template](/static/images/godot/script_template.png)

Nodes naturally emit **Signals** when a specific action happens to them, the signals can then be **connected** to functions inside scripts that execute an action afterwards. We can implement our own signals if the default nodes do not emit a signal when we want.

![Signals](/static/images/godot/signals.png)

Luckily the Button node emits the `_pressed()` signal. To connect the signal to the script we will use the `Node.get_node()` function, this will fetch the `Object Path` of the Button node relative to the script, then we will use the `Object.connect()` function to listen for `_pressed()` and finally execute the function `_on_Button_pressed()` each time the signal is emitted.

```gdscript
extend Panel

func _ready():
    get_node('Button').connect('pressed', self, '_on_Button_pressed')

func _on_Button_pressed():
    get_node('Label').text = 'Hello'
```

There are two ways of saving an `Object Path` into a variable for multiple uses across the script:

```gdscript
# First way
var my_label
func _ready():
	my_label = get_node("MyLabel")

# Second way
onready var my_label = get_node("MyLabel")
```

### Processing

Godot includes two functions that are executed continuously. 

The first one is `Node._process()` and when implemented on any script it activates Godot's idle processing calling it every **Idle Frame**, in other words the frequency of the calls will vary depending on the FPS of the application. If the implementation needs to simulate a constant action the **Delta** parameter counts the time that each frame took so that you can scale the action accordingly. Note that once activated you can stop Godot's idle processing with `Node.set_process()`.

The second one is `Node._physics_process()`, this one is called each time before a **Physics Step** is calculated, for example to check if a key is still being pressed. By default 60 physics steps are calculated per second. You can change this setting on `Project Settings - Physics - Common - Physics FPS`. Note that even in an optimized game `_process()` will be called *after* the physics step.

### Groups

We can group nodes with `Node.add_to_group()`, groups allows us to execute a function implemented by its members with `SceneTree.call_group()`. 

For example if every *enemy* member of a *enemies* group listens for a *discovered* signal emitted by the *player* then the first *enemy* intercepts the signal it can send an order to the *enemies* group members to execute their `player_was_discovered` function.

```gdscript
func _ready():
    add_to_group('enemies')

func _on_discovered():
    get_tree().call_group('enemies', 'player_was_discovered')
```

You can get a list of every member in a group with the `SceneTree.get_nodes_in_group()` function. Note that the `SceneTree` object includes other useful methods for manipulating nodes, changing the scene and pausing or exiting the game. 

### Notifications

On a low level, methods like `_ready()` are actually *overridable* virtual methods that get called through a notification system, you may need to access the notification system directly.

```gdscript
func _notification(what):
    match what:
        NOTIFICATION_READY:
            print("Same as implementing _ready().")
```

Overridable `Node` methods:

1. `_enter_tree()`: Called when only the node finishes loading becomes active. 
2. `_ready()`: Called after `_enter_Tree()`, when every child node has been loaded and become active.
3. `_exit_tree()`: Called when the node and every child node has unloaded and become inactive.
4. `_process(delta)`: Called every idle frame as soon as it can.
5. `_physics_process(delta)`: Called every before every physics step.

### Nodes

To create new nodes we use `Node.new()`. To add the node as a child of the Script's node we use `Node.add_child()`. To delete a node and immediately we use `Note.free()`. Note that freeing a node while it's emitting a signal or executing a function will terminate the app. To wait for the signal or function to finish before freeing the node we use `Node.queue_free()`.

```gdscript
var s
func _ready():
    s = Sprite.new()
    add_child(s)

func _someaction():
    s.queue_free()
```

### Scenes

To link a scene we first need to load its file into memory as a `PackedScene` object, we can do this while parsing the script with `preload()` or after the script's node has loaded into the scene with `load()`. 

Then we convert the `PackedScene` object into a tree of nodes using the `PackedScene.instance()` method. This is a two step process because when we have the scene already loaded into memory we can instance it multiple times with minimal performance cost.

```gdscript
var scene = load("res://myscene.tscn") 
var node = scene.instance()
func _ready():
	add_child(node)
```

We can load a script file inside another script or we can register the script as a new `Class` and then extend it. To create a new class we use the keyword `class_name` and an optional icon. Registering a class means makes it global and can be accessed anywhere, however it cannot be unloaded from memory and you may run into a cyclic reference error: You can't reference a registered class *foo* in the fields of another registered class *bar* if *bar* has referenced *foo* or another script that depends on *foo*.

```gdscript
extends Node
class_name MyClassName, "res://path/to/icon16x16.png"
func _ready():
    var this = MyClassName
    var cppNode = MyCppNode.new()
	cppNode.queue_free()
```

### Signals

The *observer* pattern focuses on the emitters and their signal rather than on the listener continuously checking on an action, in this way the listener can wait idle and then act upon hearing the signal. 

The relationship between emitter and listener is *decoupled* meaning that in a way the emitter is sending its signal to no one in particular and the same with the listener.

```gdscript
# Blinking Sprite
extends Node
onready var OneSecondTimer = $Timer
onready var MainSpriteImage = $Sprite
func _ready():
    OneSecondTimer.connect("timeout", self, "_on_Timer_timeout")
func _on_Timer_timeout() -> void:
    MainSpriteImage.visible = !MainSpriteImage.visible
```

Note the use of the dollar sign as shorthand code for `Node.get_node()`. 

To custom signals we declare them with the keyword `signal`.

```gdscript
# Now this node emits my_signal upon loading into the scene.
extends Node
signal my_signal(value, other_value)
func _ready():
    emit_signal("my_signal", true, 42)
```

***

## My First Game

We will create the [Dodge the Creeps](https://docs.godotengine.org/en/stable/_downloads/e79a087a28c8eb4d140359198a122c0f/dodge_assets.zip) game. 

* Create the scenes **Main**, **Player**, **HUD** and **Mob**. 
* Change `width` to 480 and `height` to 720 inside `Proyect - Settings - Display - Window`.
* Set the `Mode` to 2D and the `Apect` to keep. This will allow rescaling of the window.

In the **Player** scene we:

1. Create an Area2D and rename it Player. This area will detect collisions via overlaps.
2. Select the option in the toolbar to make the object's children non selectable.
3. Add an AnimatedSprite to the Area2D. This will render the appearance of the player.
4. In the AnimatedSprite Frames add a SpriteFrames resource.
5. In the SpriteFrames panel add 2 animations, one called `up` and another called `walk`.
6. Add the corresponding pair of images to each animation.
7. Reduce the `AnimatedSprite - Node2D - Scale` to half (0.5, 0.5).
8. Add a CollisionShape2D to the Area2D. This will be the hitbox shape for the collisions.
9. In the CollisionShape2D Shape add a CapsuleShape2D.
10. Adjust the size of the Capsule in the viewport area.
11. Create a script for the Player node that extends Area2D.

```gdscript
extends Area2D
signal hit
var screen_size
# Touchscreen target
var target = Vector2()
# Speed in pixels/sec
export var speed = 400  

func _ready():
	# Get the viewport screen size
	screen_size = get_viewport_rect().size
	# Hide the player until we start a new round
	hide()
	# Listen itself for the Area2D body_entered signal
	self.connect("body_entered", self, "_on_Player_body_entered")

# If touchscreen is detected update target's location
func _input(event):
	if event is InputEventScreenTouch and event.pressed:
		target = event.position

func _process(delta):
	# Stop all movement, movement vector 0
	var velocity = Vector2(0,0) 
	
	# If the OS isn't windows then enable touchscreen
	if OS.get_name() != "Windows":
		# Use the updated target to modify movement vector
		if position.distance_to(target) > 10:
			velocity = target - self.position
	
	# If touchscreen isn't active use keyboard instead
	# Modify movement vector based on key pressed
	if Input.is_action_pressed("ui_right"):
		velocity.x += 1
	if Input.is_action_pressed("ui_left"):
		velocity.x -= 1
	if Input.is_action_pressed("ui_down"):
		velocity.y += 1
	if Input.is_action_pressed("ui_up"):
		velocity.y -= 1
	
	# If vector is not 0 then keys are being pressed
	if velocity.length() > 0:
		# Correct for diagonal movement
		velocity = velocity.normalized() * speed
		# Play the animation, a key is being pressed
		$AnimatedSprite.play()
	else:
		# Keys are not being pressed, stop the animation
		$AnimatedSprite.stop()
		
	# Change Player's position based on the current vector state.
	self.position += velocity * delta
	# Limit Player's position to the screen size.
	self.position.x = clamp(self.position.x, 0, screen_size.x)
	self.position.y = clamp(self.position.y, 0, screen_size.y)
	
	if velocity.x != 0:
		# For right or diagonal use Walk and disable V-Flip
		$AnimatedSprite.animation = "walk"
		$AnimatedSprite.flip_v = false
		# If left use Walk but activate H-Flip.
		$AnimatedSprite.flip_h = velocity.x < 0
	elif velocity.y != 0:
		# For up use Up. For down use Up but activate V-Flip.
		$AnimatedSprite.animation = "up"
		$AnimatedSprite.flip_v = velocity.y > 0

# Function executed when itself emits body_entered
func _on_Player_body_entered(body):
	# Turn off collisions, stop additional emissions of the signal
	# Deferred makes a queue because they may be multiple collisions
	$CollisionShape2D.set_deferred("disabled", true)
	# Hide the player, it has died
	hide()
	# Emit the hit by enemy signal to other control nodes
	emit_signal("hit")

# Function executed when we start a new round
func start(pos):
	# Turn collisions back on
	$CollisionShape2D.disabled = false
	# New round, go to starting position and show the player
	self.position = pos
	target = pos
	show()
```

In the **Mob** scene we:

1. Create a RigidBody2D and name it Mob
2. Select RigidBody2D gravity to 0.
3. Select `PhysicsBody2D - Mask` and deactivate first option


Creamos un RigidBody2D y lo renombramos Mob
Seleccionamos gravedad = 0
Seleccionamos PhysicsBody2D-Mask y desactivamos el primer recuadro
Asi evitamos que los enemigos colisionen entre si
Seleccionamos opcion (no seleccionar hijos) en el viewport toolbar
Creamos un hijo AnimatedSprite
Creamos un SpriteFrames
Creamos animaciones para fly, swim y walk
Agregamos imagenes correspondientes a cada animacion
Activamos propiedad Playing to On para que se active automaticamente
Ajustamos el FPS, 3 para fly, y 4 para swim y walk.
Seleccionamos animacion por defecto Right
En Node2D-Scale reducimos el tamaño a (0.75)
Creamos un CollisionShape2D
Agregamos un CapsuleShape2D como el Shape del sprite
Rotamos el Shape 90 grados
Ajustamos al tamano de la animacion en el viewport.
Agregamos un Visibility Notifier 2D como Visibility
Agregamos un Script al Mob

```gdscript
extends RigidBody2D
export var min_speed = 150  # Minimum speed range.
export var max_speed = 250  # Maximum speed range.
var mob_types = ["walk", "swim", "fly"]
func _ready():
    $AnimatedSprite.animation = mob_types[randi() % mob_types.size()]
    $VisibilityNotifier2D.connect("screen_exited", self, "_on_Visibility_screen_exited")
func _on_Visibility_screen_exited():
    queue_free()
func _on_start_game():
    queue_free()
La velocidad inicial y animacion de cada mob nuevo se da al azar dentro de un rango determinado. La forma estandar para obtener un numero entero entre 0 y n-1 es mediante randi()%n, con esto podemos obtener un index para la animacion. Cuando el VisibilityNotifier2D emite screen_exited se activa la funcion (on_Visibility_screen_exited()) que elimina la instancia. El queue_free() de on_start_game elimina todos los mobs cuando se inicia una nueva ronda.

```

MAIN

Creamos un Node llamado Main
Instanciamos Player y Mob
Agregamos un MobTimer (spawn), ScoreTimer (more score per second), StartTimer (delay before starting) y un Position2D como StartPosition
Ponemos el MobTimer a 0.5, ScoreTimer a 1 (One Shot) y StartTimer a 2
Ponemos StartPosition a (240, 450)
Agregamos un Path2D como MobPath y agregamos cuatro puntos en las esquinas
Cerramos el path, los puntos tienen que estar en sentido horario para que el spawn sea interno
Agregamos un PathFallow2D como MobSpawnLocation y como hijo de MobPath
Agregamos un Script a Main
El PathFallow2D va a seguir el Path2D y cada que pase el MobTimer termine se crea una nueva instancia de Mob rotando al azar medainte randomize() para que se muevan en direcicones aleatorias.

```gdscript
extends Node
export (PackedScene) var Mob
var score

func _ready():
    randomize()
    $ScoreTimer.connect("timeout", self, "_on_ScoreTimer_timeout")
    $MobTimer.connect("timeout", self, "_on_MobTimer_timeout")
    $StartTimer.connect("timeout", self, "_on_StartTimer_timeout")
    $Player.connect("hitByEnemy", self, "game_over")
    $HUD.connect("start_game", self, "new_game")

func game_over():
    $ScoreTimer.stop()
    $MobTimer.stop()
    $HUD.show_game_over()
    $Music.stop()
    $DeathSound.play()

func new_game():
    score = 0
    <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>l</mi><mi>a</mi><mi>y</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">Player.start(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">.</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mopen">(</span></span></span></span>StartPosition.position)
    $StartTimer.start()
    $HUD.update_score(score)
    $HUD.show_message("Get Ready")
    $Music.play()

func _on_StartTimer_timeout():
    $MobTimer.start()
    $ScoreTimer.start()

func _on_ScoreTimer_timeout():
    score += 1
    $HUD.update_score(score)

func _on_MobTimer_timeout():
    # Choose a random location on Path2D.
    $MobPath/MobSpawnLocation.set_offset(randi())
    var mob = Mob.instance()
    add_child(mob)
    # Set the mob's direction perpendicular to the path direction.
    var direction = $MobPath/MobSpawnLocation.rotation + PI / 2
    # Set the mob's position to a random location.
    mob.position = $MobPath/MobSpawnLocation.position
    # Add some randomness to the direction.
    direction += rand_range(-PI / 4, PI / 4)
    mob.rotation = direction
    # Set the velocity (speed & direction).
    mob.linear_velocity = Vector2(rand_range(mob.min_speed, mob.max_speed), 0)
    mob.linear_velocity = mob.linear_velocity.rotated(direction)
    $HUD.connect("start_game", mob, "_on_start_game")
```

La variable exportada Mob utiliza un archivo PackedScene que se utilizara al instanciar los Mobs. Tambien guarda la variable (score) de la escena HUD la cual aumenta cada segundo mediante el timer (ScoreTimer). El (StartTimer) solo se activa una vez al iniciar el juego el cual solo inicia cuando se presiona el boton de Start del HUD. Finalmente el tercer timer selecciona un lugar random del Path para crear nuevos Mobs y los rota al azar utilizando rand_range.

Game over se ejecuta solo cuando el Player emite la señal personalizada hitByEnemy. En las funciones que requieren angulos GDScript utiliza radianes por defecto, para pasar a grados y viceverza utilizar deg2rad() y rad2deg().

HUD

Creamos un CanvasLayer como HUD
Creamos ScoreLabel, MessageLabel, StartButton y MessageTimer.
En ScoreLabel ponemos 0, cambiamos la fuente a Xolonium y el size a 64.
Utilizamos el layout para controlar automaticamente la posicion
Para ajustar manualmente utilizamos las variables anchor y margin.
Agregamos el siguiente script a HUD.
extends CanvasLayer
signal start_game

```gdscript
func _ready() -> void:
    $MessageTimer.connect("timeout", self, "_on_MessageTimer_timeout")
    $StartButton.connect("pressed", self, "_on_StartButton_pressed")
func _on_MessageTimer_timeout():
    $MessageLabel.hide()
func _on_StartButton_pressed():
    $StartButton.hide()
    emit_signal("start_game")
func show_message(text):
    $MessageLabel.text = text
    $MessageLabel.show()
    $MessageTimer.start()
func show_game_over():
    show_message("Game Over")
    yield($MessageTimer, "timeout")
    $MessageLabel.text = "Dodge the\nCreeps!"
    $MessageLabel.show()
    yield(get_tree().create_timer(1), "timeout")
    $StartButton.show()
func update_score(score):
    $ScoreLabel.text = str(score)
```

El CanvasLayer a diferencia de un panel se dibuja por encima del juego, al iniciar el juego desaparecemos el mensaje del titulo y el boton. Luego cambiamos el texto del titulo a (Get ready) por dos segundos que dura el (MessageTimer) y actualizamos el Score con el texto de ScoreLabel.

En el caso de que termine el juego mostramos el mensaje (Game Over), la funcion yield nos permite forzar la emision de una señal. Despues de dos segundos volvemos al titulo original y despues de 1 segundo volvemos a aparecer el boton de Start.

Para cambiar el background utilizamos un ColorRect en Main. Para agregar efectos de sonido utilizamos AudioStreamPlayer y llamamos a sus funciones play y stop. Para que el boton de start se active al presionar la tecla de espacio agregamos un Shortcut a sus propiedades.

Exportar
Nos vamos a Project-Settings-InputDevices-Pointing y activamos la opcion para emular touch a partir de un mouse, esto nos permitira dar click en el boton de start en un touchscreen. Para distintas pantallas activamos Stretch 2D con Keep Aspect. Para mover el Player mediante touch utilizamos los siguientes cambios a su Script:

```gdscript
#TouchTarget Vector
onready var target = Vector2()
# Funcion del TouchTarget Vector
func _input(event):
    if event is InputEventScreenTouch and event.pressed:
        target = event.position
func _process(delta):
    # Moverse hacia TouchTarget parar cuando lleguemos
    if position.distance_to(target) > 10:
        velocity = (target - position).normalized() * speed
    else:
        velocity = Vector2()
    # Eliminar inputs de keyboard
func start(pos):
    #TouchTarget Initial Pos
    target = pos
```

Finalmente utilizamos Editor-ManageTemplates para seleccionar los targets a los que exportaremos el juego. Editamos los detalles del export mediante Project-Export. Creamos un nuevo preset y seleccionamos la plataforma.

Para Windows, Linux y MacOS genera directamente los archivos ejecutables. Para Android se necesita tener AndroidSDK y JavaJDK, en AndroidStudio se instala el AndroidSDKPlatformTools que a su vez instala el comando adb. Godot utilizara el abd y la direccion de un keystore para exportar a Android:

```gdscript

keytool -keyalg RSA -genkeypair -alias androiddebugkey -keypass android -keystore debug.keystore -storepass android -dname "CN=Android Debug,O=Android,C=US" -validity 9999

```
Al exportar a Android se genera un apk que puede ser descargado en el telefono si esta en modo developer. Si Godot detecta el telefono conectado en vez de exportar el apk aparecera un boton para crearlo y descargarlo automaticamente al telefono.

Para IOS se necesita tener macOS y Xcode instalado, Godot necesitara el App Store Team ID dentro de la membresia, luego necesitara iconos e imagenes obligatorias del dispositivo. Los archivos que Godot generara estaran listos para ser abiertos en Xcode y compilados.

Para HTML5 se crean varios archivos que pueden ser ejecutados por cualquier servidor, incluso uno local ya que necesitan de un puerto para ejecutar los cripts. Se puede crear un server rapidamente mediante python -m http.server 9000 dentro del directorio que contiene los archivos. Si la exportacion incluye la consola de debug se puede desactivar con Export With Debug.


Diseño
Nodos de Control
Pantalla de Titulo
GUI
GUI by Code
Splash Screen
Animaciones
Recursos
Archivos
SceneTree
Singletons

Editor Manual
https://godotengine.org/news https://godotengine.org/community https://www.facebook.com/groups/godotengine/ https://twitter.com/godotengine https://github.com/godotengine https://www.reddit.com/r/godot/